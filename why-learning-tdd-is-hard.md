Почему изучать TDD трудно и что с этим делать. Часть 1.
=======================================================

*От переводчика. В русскоязычном интернете мало информации о TDD и в основном описываются механические действия разработчика. Главное же – идея – остается без внимания. Эта статья является попыткой восполнить этот пробел. Так же скажу, что она не для тех, у кого нет времени на тесты (http://habrahabr.ru/post/112685/), и тем более не для тех, кто не осознает важность слабосвязанной архитектуры. Статья адресована тем, кто делает или собирается сделать первые шаги в TDD.*

Недавно мне предложили провести TDD-тренинг, что включало работу в паре с очень толковым разработчиком, слабо знакомым с этой техникой. Я заметил кое-что интересное: многие из вопросов, которые он задал, были поразительно похожи на те, что возникали у меня при знакомстве с TDD. Также было видно, что большое число вопросов происходило из неверных предположений об этой технике. Тот факт, что мы оба сделали похожие предположения, заставил меня задуматься о причинах этого. 

В этой заметке мы постараемся понять, что именно является трудным в процессе освоения TDD до уровня использования в повседневных задачах. Затем разберемся с тем, как и почему TDD работает, с целью предоставить новичкам возможность критически оценить уже имеющуюся у них информацию и избежать неверных предположений, которые могут замедлить процесс обучения. Наконец, мы рассмотрим способы использования новых знаний для ответов на вопросы, обычно мешающие начать применять TDD.

Почему же это так трудно?
-----------------------------------------
Я думаю, что существует несколько причин. Во-первых, сама шумиха вокруг TDD достаточно вредна для процесса обучения. В зависимости от того, откуда взялась информация об этой технике, легко составить впечатление, что она является единственно верным способом разработки, и что благодаря следованию простым шагам код начинает сиять чистотой и наполняется красивыми и очевидными абстракциями. Однако это не так для всего, кроме самых простых примеров.

Нереалистичные ожидания, вызванные шумихой, могут привести к фокусированию на самом алгоритме, без понимания идеи, стоящей за ним, что приводит к неэффективному применению TDD. А это, в свою очередь, действует очень негативно на человека, которого процесс, отлично сработавший при реализации стека, привел к неудаче при попытке вывести что-то самое простое на веб-страницу. 

TDD не является заменой думанию и не отменяет необходимость в навыках проектирования. В действительности, TDD ничего не делает самостоятельно – все делает разработчик, и эта техника хороша настолько, насколько хорош разработчик. Более реалистичный взгляд заключается  в том, что TDD – это просто инструмент, который может быть использован для облегчения работы. Конечно, эта техника может быть очень полезной, но все же конечная цель – это выполнить поставленную задачу*, а не всегда начинать создание мельчайшего кусочка кода с несрабатывающего теста.

**Дряной код выполненным заданием не считается.**

Еще одной причиной трудностей в изучении TDD я считаю тот факт, что эта техника сама по себе мало учит тому, как ее применять. Обычный подход при изучении чего-то нового состоит в простом следовании правилам, пока не наберется достаточно опыта для понимания того, когда следует применять эти правила, а когда – нарушать. В конечном счете приходит видение идеи, стоящей за этими правилами, и того, что их применение главным образом зависит от контекста. Отсюда же происходит типовой ответ «а это зависит от ситуации» *(«it depends» -прим. перев.)*.

Итак, правила TTD предельно просты (http://davesquared.net/2008/02/tdd-is-easy.html). В самом деле, они настолько просты, что не дают возможности просто применять их до достижения уровня мастерства, необходимого для действительно успешного использования TDD. Наоборот, вам необходимо уже уметь строить правильные абстракции, что требует глубоких знаний в области объектно-ориентированного дизайна, паттернов, принципов SOLID и DRY, и тому подобного. Пока не будут заполнены пробелы в этих знаниях, применять TDD будет невозможно. В-общем, отлично выявляя дефицит знаний в некоторых областях, TDD плохо справляется с его восполнением.

Пойми технику, затем научись применять ее
-----------------------------------------
Я думаю, хорошим способом облегчить изучение TDD является раннее концентрирование на том, как эта техника работает. Конечно, стоит начать с простейших примеров разработки классов вроде Stack или StringCalculator, чтобы усвоить процесс «красная полоса – зеленая полоса – рефакторинг». Но после надо остановиться и подумать над тем, что, собственно, это процесс делает.

Мы начинаем с написания несрабатывающего теста. Зачем? Существующие тесты проходят нормально, значит, в коде нет известных проблем. Создав тест для выявления недостающего функционала, мы четко выявляем задачу, которую собирается решить. Фиксируя задачу и, следовательно, ее возможные решения мы делаем процесс работы над ней более простым. Мы так же гарантируем, что результирующий код будет покрыт тестами на правильность реализации и защищен от регрессии (хотя этого можно достичь и без TDD с помощью любого достаточно глубокого автоматического теста).

Но самым важным здесь является создание наброска будущей архитектуры. Просто делается это не на доске для рисования (что имеет свои преимущества), а прямо в коде, что позволяет незамедлительно понять, насколько просто использовать и тестировать этот код. Посмотрим, какие вопросы возникают при создании самого первого, несрабатывающего теста:
 - В чем заключаются обязанности тестируемой системы *(в оригинале SUT, System Under Test – прим. перев.)*? Иными словами, что и когда она должна делать?
 - Какой API удобен для того, чтобы тестируемый код выполнял задуманное?
 - Что нужно тестируемой системе для выполнения своих обязательств (данные, другие классы)?
 - Что мы имеем на выходе и какие есть побочные эффекты?
 - Как узнать, что система работает правильно? Определена ли эта «правильность»?

При создании кода все перечисленные вопросы когда-нибудь должны быть заданы, и сила TDD в предоставлении удобного инструмента для этого. Вместо процесса поочередного решения вопросов  с предотвращением потенциальных конфликтов по мере возникновения TDD позволяет задать абстрактный вопрос «Как мне написать следующий тест?» и в процессе его решения ответить на ряд конкретных вопросов. Вот почему TDD не лучше программиста – все равно придется искать ответы на те же самые ключевые вопросы, что требует соответствующих знаний и опыта. TDD просто облегчает поиск.

Что именно делает упомянутый выше абстрактный вопрос? Как и любая хорошая абстракция, он дает возможность рассматривать множество мелких составляющих как одно целое, при создании которого можно разом применить все имеющиеся технические и другие навыки. Кроме того, поиск ответа на этот единственный вопрос облегчает еще одно свойство TDD: предоставление быстрой и точно обратной связи с кодом.  

Процесс создания теста дает всестороннюю оценку разрабатываемому модулю. Подготовка к использованию чересчур громоздка? Возможно, у нас слишком много вспомогательных классов (или они нарушают Закон Деметры) и можно попытаться скрыть их за дополнительной абстракцией. Получается слишком много сценариев использования или фикстур? Вероятно, тестируемый код имеет слишком много обязанностей. Трудно изолировать тестируемое поведение или непонятно, как его проверить? Наверное, у нас неправильное API или сама абстракция, и ее надо выделить как-то иначе. С TDD эти проблемы становятся очевидными мгновенно. Их решение требует навыков проектирования, таких же, каких требуют другие методики разработки. Но создание теста в самом начале дает отличную возможность отреагировать на ошибки и проверить проект модуля до его реализации. Самое дешевое время для исправления кода – до его написания.

Затем мы пишем самый простой код, удовлетворяющий тесту. Как ни странно, это наименее интересная часть TDD. Мы уже закончили всю тяжелую работу по выявлению требуемого поведения, и сейчас осталось только реализовать его. Реализация слишком сложна? Тогда придется вернуться назад и изменить тест – мы только что узнали с помощью TDD, что попытались сделать слишком большой шаг в разработке модуля.  Реализация тривиальна и имеет очевидные недоработки? Отлично, теперь мы знаем, каким будет следующий тест.

И вот мы на шаге рефакторинга. Только что созданный код удовлетворяет тесту, но мы были сфокусированы на очень маленьком участке приложения и сейчас самое время охватить взглядом всю картину. Если было реализовано решение «в лоб», то можно избавиться от дублирования или выделить отдельный метод, чтобы код лучше описывал то, что он делает.  Еще более важным является выявление высокоуровневого дублирования – повторения не просто участков кода, а схожего поведения, которое может быть выделено в абстракцию или выведено на структурный уровень.


Почему изучать TDD трудно и что с этим делать. Часть 2.
=======================================================

Как все это использовать?
-------------------------
Хороший вопрос. Итак, польза TDD в том, что этот инструмент помогает четко определить границы текущей задачи, предоставляет простой способ одновременной работы с мелкими деталями, относящимися к проблеме, и предоставляет быструю обратную связь с кодом, сообщая, насколько удачно получившееся решение. Именно эти факты помогут нам преодолеть трудности в изучении TDD. 

### Какие тесты писать?
Самый простой (хотя и точный) ответ - любые тесты, дающие возможность оценивать классы и проектировать дальше. Но этот ответ плохо подходит для начинающих, поэтому придется углубиться в детали.

С чем мне пришлось больше всего бороться, изучая TDD, так это с переходом от простых примеров к использованию TDD в настоящих проектах. Выбрав тест для класса пониже в иерархии, я получал трудности со вставкой получившегося кода обратно в проект. Проблемой здесь являлось то, что я не думал о тестах как о способе узнать, что мне нужно на самом деле. И только при использовании теста, описывающего решение проблемы, получались действительно полезные абстракции. Весь фокус в том, чтобы создавать тесты, инкапсулирующие  знания о текущей проблеме.

Посмотрим на более выраженный случай, иллюстрирующий это. Скажем, мы имеем совершенно новый проект. Значит, мы даже еще не знаем, какие классы будут нам нужны. Как использовать TDD, чтобы что-то узнать о будущей структуре классов, когда еще нет вообще ни одного класса? Напишем тест, описывающий разрабатываемый функционал (или сценарий). Это будет скорее приемочный, нежели юнит-тест. Нигде не написано, что TDD основывается исключительно на юнит-тестах, но большинство новичков думают, что процесс основан именно на них, и из этого вытекает дальнейшее непонимание. Так вот, такой подход позволяет создать базовый скелет приложения, который в дальнейшем будет развиваться и обрастать плотью. Тесты позволят оценивать, насколько хорошо мы сумели разделить требуемый функционал на контролируемые, тестируемые абстракции. Вдобавок мы получим отличный интерфейс к системе, который пригодится в будущем при создании интеграционных тестов. Эта книга (http://www.growing-object-oriented-software.com/) является отличным источником примеров.

Как только мы определили базовое поведение функционала посредством приемочного теста, мы создаем инфраструктуру, требуемую для теста (построения, непрерывная интеграция), и переходим к более конкретным тестам для выделения внутренних классов приложения. Возможно, это не понадобиться – направления, указанного приемочными тестами будет достаточно для реализации функционала.

### Но ты только что написал код, не создав сначала теста!
Запросто. TDD обеспечивает обратную связь с кодом. Когда вы уже знаете, что именно нужно (например, если работа заключается в дополнении мелкими частями готовой архитектуры), та часть TDD, что отвечает за проектирование, не дает много пользы. Единственное преимущество предварительного написания тестов здесь в том, что можно убедиться, что изначально они не срабатывают; это способ протестировать сами тесты. В этом случае подход "сначала тесты" является техникой создания кода, покрытого тестами, а не проектирования.

Чем меньше неизвестных, тем меньше нужно тестов, чтобы их найти и тем большими шагами можно двигаться.

### Используя паттерн MVVM, ты создал представление без предварительного теста!
Мы уже узнали, что TDD ограничивает текущую задачу, так же как и дает возможность понять, насколько хорошо ее решение. Конечно, TDD – далеко не единственный способ получить как первое, так и второе. Технологии создания представлений (WPF, MVC-фреймворки, GTK, WebForms и т.д.) сами по себе налагают существенные ограничения на код в части взаимодействия с UI.

При использовании паттернов выделения представления, таких как MVVM, мы можем определить необходимые свойства и команды у ViewModel вообще без тестов. Мы ограничены выбранной технологией построения интерфейса, а так же внешним дизайном, проработанным в ходе обсуждения (которое также является инструментом, обеспечивающим быструю обратную связь) с заказчиком.

Итак, TDD не является единственным способом ограничить задачу и получить оценку решения. Там, где существуют реальные условия, не следует игнорировать их и придумывать искусственные.

Примечание: Я столкнулся с трудностями при попытке воссоздать паттерны представления при помощи следования принципам TDD: как можно, используя только тесты, в итоге получить MVP, MVVM и т.д? Думаю, что это сложно из-за того, что с одной стороны, у нас есть абсолютно реальный UI-инструментарий, а с другой - только воображение и тесты. Существуют факторы, которые не вытекают из тестов, но являются такими же важными источниками информации. Если кому-то удалось получить в чистом виде паттерн отделения представления только при помощи TDD, пожалуйста, дайте знать.

### Я застрял! Застрял в тестах и не знаю, что делать.
Со мной такое случалось столько раз, что я стесняюсь об этом говорить. Придумывая тесты для каждой строки кода, включая те, что появляются в процессе рефакторинга, в конце концов я оказывался в лабиринте бессмысленных абстракций. Помните, TDD не является заменой думанию, вам все равно надо уметь просто писать чистый код!

Если процесс не дает необходимой информации, вернитесь назад и попробуйте сделать иначе. Обсудите идеи с коллегами. Попробуйте поработать, используя покрытие тестами более высокого уровня абстракции. Просто попробуйте другие подходы - часто проще испытать в деле три разных решения, чем теоретически выявить одно самое лучшее заранее. TDD является хорошим, но не единственным средством ограничить проблему и выйти на решение. Сделайте то, что необходимо прямо сейчас, чтобы решить задачу, но не забудьте вернуться и попытаться понять причину остановки позже.

На заметку: Если не удалось решить проблему с помощью TDD, сделайте пометку об этом перед тем, как пробовать что-то еще. Вам важно понять, были ли эта задача в принципе не решаема с помощью TDD, или вам просто не хватило знаний. Уловить разницу не получится, если сдаться слишком быстро. Лично меня следование этому принципу привело в свое время к открытию таких штук как мокирование, IoC-контейнеры, соглашения, BDD и т.д. (и я все равно еще далек от полного отсутствия пробелов в знаниях).


### TDD? BDD? ATDD? Что именно мне нужно?
Вы можете заметить, что использование TDD специфично для каждой задачи (и для каждого разработчика). Разнообразные задачи создают разные проблемы проектирования и требуют разнообразных видов обратной связи. Это значит, что нам следует задействовать TDD разными способами, чтобы получать разные оценки разрабатываемого кода и использовать их в развитии архитектуры. Такими способами могут быть "сверху внизу" или "снизу вверх". Иногда мы можем опираться большей частью на приемочные тесты. Иногда лучше использовать большое количество модульных тестов. Некоторые проблемы хорошо решаются с помощью тестов "от края до края", с использованием реальных внешних баз данных или сервисов (у этого подхода есть свои тонкости, но если он дает необходимую обратную связь и обеспечивает развитие архитектуры - используйте его).

В общем, здесь нет единственного верного ответа. Главная цель - получение обратной связи с кодом, над которым идет работа в данный момент.

Заключение
----------
Хотя инструкции процесса TDD просты, сама техника таковой не является. Инструкции обеспечивают лишь самую минимальную помощь на старте, в то время как шумиха вокруг TDD формирует совершенно нереалистичные ожидания.

Мы можем решить эту проблему, пытаясь понять, как работает TDD и увидеть идею, стоящую за алгоритмом. Мы видим, что TDD на самом деле является инструментом для ограничения задачи, инкапсулирования процесса дизайна  с помощью абстрактного вопроса «каким будет следующий тест», и предоставления возможности быстро оценивать результаты наших изысканий. По существу, TDD дает отличный способ продумывать и итеративно развивать дизайн приложения. 

Поняв это, мы можем преднамеренно использовать TDD для получения обратной связи с разрабатываемым кодом и использования этой информации для решения задач проектирования. Мы не ограничиваемся только юнит-тестами и постоянно переключаемся между уровнями абстракции тестов (чего совсем нет в демонстрационных примерах использования TDD). И мы запросто обходимся без TDD там, где есть другие способы получения обратной связи с кодом, такие как фреймворки отделения UI или технологии хранения данных.

Мы так же не будем впадать в отчаяние в случае невозможности применения правил TTD, так как знаем, что эта техника всего лишь является инструментом проектирования, и всегда найдутся пробелы в знаниях или недостаток опыта, которые придется заполнить перед тем, как станет возможным решать новые задачи. То, что TDD является отличным индикатором недостатка знаний, дает шанс пополнить их запас прямо сейчас. Это намного лучше блаженного забвения, приводящего, в конце концов, к срыву сроков сдачи проекта, или, что еще хуже, бесконечному повторению одних и тех же ошибок.

Проектировать всегда трудно. TDD позволяет сконцентрироваться на дизайне и понять, как сделать его лучше.

Надеюсь, эти размышления откроют Вам иной взгляд на TDD и сделают процесс изучения этой техники более простым *(и осмысленным -  прим. перев.)*. TDD стоит затраченных усилий. Желаю удачи!
